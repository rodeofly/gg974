// Generated by CoffeeScript 2.3.0
var DnDFileController, autre, circle, circlesGroup, colors, dnd, drag_line, force, height, i, j, jeu, joueur, keydown, keyup, lastKeyDown, lastNodeId, links, mousedown, mousedown_link, mousedown_node, mousemove, mouseup, mouseup_node, nodes, path, pathsGroup, premier_appel, ref, resetMouseVars, restart, save, selected_link, selected_node, sgt, spliceLinksForNode, spoiler, statut, svg, tick, width;

premier_appel = false;

// set up SVG for D3
width = 800;

height = 480;

colors = d3.scale.category10();

// define arrow markers for graph links
svg = d3.select('#graf974').append('svg').attr('oncontextmenu', 'return false;').attr('width', width).attr('height', height);

svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -10 20 20').attr('refX', 12).attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-10L20,0L0,10').attr('fill', '#000');

svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -10 20 20').attr('refX', 8).attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto').append('svg:path').attr('d', 'M20,-10L0,0L20,10').attr('fill', '#000');


// line displayed when dragging new nodes
drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');

// set up initial nodes and links
//  - nodes are known by 'id', not by index in array.
//  - pion edges are indicated on the node (as a bold black circle).
//  - links are always source < target; edge directions are set by 'left' and 'right'.
nodes = [
  {
    id: 0,
    pion: false,
    depart: true,
    arrivee: false // parce que depart
  },
  {
    id: 1,
    pion: false,
    depart: false,
    arrivee: false
  },
  {
    id: 2,
    pion: true,
    depart: false,
    arrivee: true // parce que arrivee
  }
];

lastNodeId = 2;

links = [
  {
    source: nodes[0],
    target: nodes[1],
    left: false,
    right: true
  },
  {
    source: nodes[1],
    target: nodes[2],
    left: false,
    right: true
  },
  {
    source: nodes[0],
    target: nodes[2],
    left: false,
    right: true
  }
];

statut = {};

for (i = j = 0, ref = lastNodeId; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
  statut[i] = 7;
}

autre = {
  "A": "B",
  "B": "A"
};

joueur = "A";

// handles to link and node element groups
pathsGroup = svg.append('svg:g');

path = pathsGroup.selectAll('path');

circlesGroup = svg.append('svg:g');

circle = circlesGroup.selectAll('g');

// update force layout (called automatically each iteration)
tick = function() {
  // draw directed edges with proper padding from node centers
  path.attr('d', function(d) {
    var deltaX, deltaY, dist, normX, normY, sourcePadding, sourceX, sourceY, targetPadding, targetX, targetY;
    deltaX = d.target.x - d.source.x;
    deltaY = d.target.y - d.source.y;
    dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    normX = deltaX / dist;
    normY = deltaY / dist;
    sourcePadding = d.left ? 22 : 12;
    targetPadding = d.right ? 22 : 12;
    sourceX = d.source.x + sourcePadding * normX;
    sourceY = d.source.y + sourcePadding * normY;
    targetX = d.target.x - (targetPadding * normX);
    targetY = d.target.y - (targetPadding * normY);
    return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
  });
  return circle.attr('transform', function(d) {
    return `translate(${d.x}, ${d.y})`;
  });
};

// init D3 force layout
force = d3.layout.force().nodes(nodes).links(links).size([width * 0.8, height * 0.8]).linkDistance(80).charge(-500).on('tick', tick);

// mouse event vars
selected_node = null;

selected_link = null;

mousedown_link = null;

mousedown_node = null;

mouseup_node = null;

// only respond once per keydown
lastKeyDown = -1;

resetMouseVars = function() {
  mousedown_node = null;
  mouseup_node = null;
  mousedown_link = null;
};

spoiler = false;

// en mode spoiler l'algo sgt est utilisé pour colorier
jeu = false;

// mode jeu ou mode édition
sgt = function(nodeId) {
  if (spoiler) {
    return d3.rgb(colors(statut[nodeId]));
  } else {
    return d3.rgb(colors(nodeId));
  }
};

// update graph (called when needed)
restart = function() {
  var arete, cell, e, g, i1, j1, k, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, m, n, o, p, passage, q, r, ref1, ref2, ref3, ref4, ref5, s, sommet, sommet2, u, v, w, x, y, z;
  for (k = 0, len = nodes.length; k < len; k++) {
    sommet = nodes[k];
    statut[sommet.id] = 7;
  }
  for (m = 0, len1 = nodes.length; m < len1; m++) {
    sommet = nodes[m];
    e = 0;
    for (n = 0, len2 = links.length; n < len2; n++) {
      arete = links[n];
      if (arete.source === sommet && arete.right) {
        e += 1;
      }
      if (arete.target === sommet && arete.left) {
        e += 1;
      }
    }
    if (e === 0) {
      statut[sommet.id] = 2; // les arrivées sont gagnantes donc en vert
    }
  }
  for (passage = o = 0, ref1 = lastNodeId; (0 <= ref1 ? o < ref1 : o > ref1); passage = 0 <= ref1 ? ++o : --o) {
    for (p = 0, len3 = nodes.length; p < len3; p++) {
      sommet = nodes[p];
      [e, s] = [0, 0];
      for (q = 0, len4 = links.length; q < len4; q++) {
        arete = links[q];
        if (arete.source === sommet && arete.right && statut[arete.target.id] === 2) {
          s += 1;
        }
        if (arete.target === sommet && arete.left && statut[arete.source.id] === 2) {
          s += 1;
        }
        if (arete.source === sommet && arete.right && ((ref2 = statut[arete.target.id]) === 2 || ref2 === 7)) {
          e += 1;
        }
        if (arete.target === sommet && arete.left && ((ref3 = statut[arete.source.id]) === 2 || ref3 === 7)) {
          e += 1;
        }
      }
      if (s > 0 && statut[sommet.id] === 7) {
        statut[sommet.id] = 3; // sommet perdant, en rouge
      } else {

      }
      if (e === 0 && statut[sommet.id] === 7) {
        statut[sommet.id] = 2; // sommet gagnant, en vert
      }
    }
  }
  
  // path (link) group
  path = path.data(links);
  // update existing links
  path.style('stroke', "black").style('fill', "black").style('stroke-width', '4px').classed('selected', function(d) {
    return d === selected_link;
  }).style('marker-start', function(d) {
    if (d.left) {
      return 'url(#start-arrow)';
    } else {
      return '';
    }
  }).style('marker-end', function(d) {
    if (d.right) {
      return 'url(#end-arrow)';
    } else {
      return '';
    }
  });
  // add new links
  path.enter().append('svg:path').attr('class', 'link').style('stroke', "black").style('fill', "black").style('stroke-width', '4px').classed('selected', function(d) {
    return d === selected_link;
  }).style('marker-start', function(d) {
    if (d.left) {
      return 'url(#start-arrow)';
    } else {
      return '';
    }
  }).style('marker-end', function(d) {
    if (d.right) {
      return 'url(#end-arrow)';
    } else {
      return '';
    }
  }).on('mousedown', function(d) {
    var destination, origine;
    if (d3.event.ctrlKey || jeu) {
      
      // select link
      mousedown_link = d;
      if (mousedown_link === selected_link) {
        selected_link = null;
      } else {
        selected_link = mousedown_link;
      }
      selected_node = null;
      if (jeu) {
        if (selected_link.right) {
          origine = selected_link.source;
          destination = selected_link.target;
        } else {
          origine = selected_link.target;
          destination = selected_link.source;
        }
        if (origine.pion) { // le pion est ici
          destination.pion = true;
          origine.pion = false; // on bouge le pion
          joueur = autre[joueur];
          $(".joueurId").text(joueur);
        }
      }
    }
    return restart();
  });
  
  // remove old links
  path.exit().remove();
  $("#matrAdj").empty().append('<tr id="sommets2"></tr>');
  $("#sommets, #sommets2").empty().append("<th>sommets</th>");
  $("#entrants").empty().append("<th>degrés entrants</th>");
  $("#sortants").empty().append("<th>degrés sortants</th>");
  $("#departs").empty();
  $("#arrivees").empty();
  for (r = 0, len5 = nodes.length; r < len5; r++) {
    sommet = nodes[r];
    if (!jeu) {
      sommet.pion = false;
    }
    sommet.arrivee = false;
    sommet.depart = false;
  }
  for (u = 0, len6 = nodes.length; u < len6; u++) {
    sommet = nodes[u];
    $("#sommets").append(`<td>${sommet.id}</td>`);
    $("#sommets2").append(`<th>${sommet.id}</th>`);
    $("#matrAdj").append(`<tr id='sa${sommet.id}'><th>${sommet.id}</th></tr>`);
    for (v = 0, len7 = nodes.length; v < len7; v++) {
      sommet2 = nodes[v];
      $(`#sa${sommet.id}`).append("<td>0</td>");
    }
    [e, s] = [0, 0];
    for (w = 0, len8 = links.length; w < len8; w++) {
      arete = links[w];
      if (arete.source === sommet && arete.right) {
        s += 1;
      }
      if (arete.target === sommet && arete.left) {
        s += 1;
      }
      if (arete.target === sommet && arete.right) {
        e += 1;
      }
      if (arete.source === sommet && arete.left) {
        e += 1;
      }
      if (arete.source === sommet && !arete.right && !arete.left) {
        e += 1;
        s += 1;
      }
      if (arete.target === sommet && !arete.right && !arete.left) {
        e += 1;
        s += 1;
      }
    }
    $("#entrants").append(`<td>${e}</td>`);
    $("#sortants").append(`<td>${s}</td>`);
    if (s === 0 && e > 0) {
      $("#arrivees").append(`<li>${sommet.id}</li>`);
      sommet.arrivee = true;
    }
    if (e === 0 && s > 0) {
      sommet.depart = true;
      if (premier_appel) {
        sommet.pion = true;
        premier_appel = false;
      }
      $("#departs").append(`<li>${sommet.id}</li>`);
    }
  }
  for (x = z = 0, ref4 = nodes.length; (0 <= ref4 ? z < ref4 : z > ref4); x = 0 <= ref4 ? ++z : --z) {
    for (y = i1 = 0, ref5 = nodes.length; (0 <= ref5 ? i1 < ref5 : i1 > ref5); y = 0 <= ref5 ? ++i1 : --i1) {
      cell = $(`table#matrAdj tr:nth-child(${x + 2}) td:nth-child(${y + 2})`);
      for (j1 = 0, len9 = links.length; j1 < len9; j1++) {
        arete = links[j1];
        if (arete.right && arete.source === nodes[x] && arete.target === nodes[y]) {
          cell.text(1);
        }
        if (arete.left && arete.source === nodes[y] && arete.target === nodes[x]) {
          cell.text(1);
        }
        if (!arete.left && !arete.right && arete.source === nodes[y] && arete.target === nodes[x]) {
          cell.text(1);
        }
        if (!arete.left && !arete.right && arete.source === nodes[x] && arete.target === nodes[y]) {
          cell.text(1);
        }
      }
    }
  }
  
  // circle (node) group
  // NB: the function arg is crucial here! nodes are known by id, not by index!
  circle = circle.data(nodes, function(d) {
    return d.id;
  });
  
  // update existing nodes (pion & selected visual states)
  circle.selectAll('circle').style('fill', function(d) {
    if (d === selected_node) {
      return sgt(d.id).brighter().toString();
    } else {
      return sgt(d.id);
    }
  }).classed('pion', function(d) {
    return d.pion;
  }).classed('arrivee', function(d) {
    return d.arrivee;
  }).classed('depart', function(d) {
    return d.depart;
  });
  
  // add new nodes
  g = circle.enter().append('svg:g');
  g.append('svg:circle').attr('class', 'node').attr('r', 12).style('fill', function(d) {
    if (d === selected_node) {
      return sgt(d.id).brighter().toString();
    } else {
      return sgt(d.id);
    }
  }).style('stroke', function(d) {
    return sgt(d.id).darker().toString();
  }).classed('pion', function(d) {
    return d.pion;
  }).classed('arrivee', function(d) {
    return d.arrivee;
  }).classed('depart', function(d) {
    return d.depart;
  }).on('mouseover', function(d) {
    if (!mousedown_node || d === mousedown_node) {
      return;
    }
    
    // enlarge target node
    d3.select(this).attr('transform', 'scale(1.1)');
  }).on('mouseout', function(d) {
    if (!mousedown_node || d === mousedown_node) {
      return;
    }
    
    // unenlarge target node
    d3.select(this).attr('transform', '');
  }).on('mousedown', function(d) {
    if (d3.event.ctrlKey || jeu) {
      return;
    }
    
    // select node
    mousedown_node = d;
    if (mousedown_node === selected_node) {
      selected_node = null;
    } else {
      selected_node = mousedown_node;
    }
    selected_link = null;
    // reposition drag line
    drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${mousedown_node.x}, ${mousedown_node.y}`);
    restart();
  }).on('mouseup', function(d) {
    var direction, link, source, target;
    if (!mousedown_node) {
      return;
    }
    
    // needed by FF
    drag_line.classed('hidden', true).style('marker-end', '');
    // check for drag-to-self
    mouseup_node = d;
    if (mouseup_node === mousedown_node) {
      resetMouseVars();
      return;
    }
    // unenlarge target node
    d3.select(this).attr('transform', '');
    // add link to graph (update if exists)
    // NB: links are strictly source < target; arrows separately specified by booleans
    source = void 0;
    target = void 0;
    direction = void 0;
    if (mousedown_node.id < mouseup_node.id) {
      source = mousedown_node;
      target = mouseup_node;
      direction = 'right';
    } else {
      source = mouseup_node;
      target = mousedown_node;
      direction = 'left';
    }
    link = void 0;
    link = links.filter(function(l) {
      return l.source === source && l.target === target;
    })[0];
    if (link) {
      link[direction] = true;
    } else {
      link = {
        source: source,
        target: target,
        left: false,
        right: false
      };
      link[direction] = true;
      links.push(link);
    }
    // select new link
    selected_link = link;
    selected_node = null;
    return restart();
  });
  
  // show node IDs
  g.append('svg:text').attr('x', 0).attr('y', 4).attr('class', 'id').text(function(d) {
    return d.id;
  });
  
  // remove old nodes
  circle.exit().remove();
  // set the graph in motion
  force.start();
};

mousedown = function() {
  var node, point;
  // prevent I-bar on drag
  //d3.event.preventDefault();
  // because :active only works in WebKit?
  svg.classed('active', true);
  if (d3.event.ctrlKey || mousedown_node || mousedown_link || jeu) {
    return;
  }
  // insert new node at point
  point = d3.mouse(this);
  node = {
    id: ++lastNodeId,
    pion: false,
    depart: false,
    arrivee: false
  };
  statut[node.id] = 7; // couleur grise a priori
  node.x = point[0];
  node.y = point[1];
  nodes.push(node);
  restart();
};

mousemove = function() {
  if (!mousedown_node) {
    return;
  }
  // update drag line
  drag_line.attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${(d3.mouse(this)[0])}, ${(d3.mouse(this)[1])}`);
  restart();
};

mouseup = function() {
  if (mousedown_node) {
    // hide drag line
    drag_line.classed('hidden', true).style('marker-end', '');
  }
  // because :active only works in WebKit?
  svg.classed('active', false);
  // clear mouse event vars
  resetMouseVars();
};

spliceLinksForNode = function(node) {
  var toSplice;
  toSplice = links.filter(function(l) {
    return l.source === node || l.target === node;
  });
  return toSplice.map(function(l) {
    return links.splice(links.indexOf(l), 1);
  });
};

keydown = function() {
  d3.event.preventDefault();
  if (lastKeyDown !== -1) {
    return;
  }
  lastKeyDown = d3.event.keyCode;
  // ctrl
  if (d3.event.keyCode === 17) {
    circle.call(force.drag);
    svg.classed('ctrl', true);
  }
  if (!selected_node && !selected_link) {
    return;
  }
  if (!jeu) {
    switch (d3.event.keyCode) {
      // backspace
      case 8:
      case 46:
        // delete
        if (selected_node) {
          nodes.splice(nodes.indexOf(selected_node), 1);
          spliceLinksForNode(selected_node);
        } else if (selected_link) {
          links.splice(links.indexOf(selected_link), 1);
        }
        selected_link = null;
        selected_node = null;
        restart();
        break;
      case 65:
        // A
        if (selected_link) {
          // set link direction to both left and right
          selected_link.left = false;
          selected_link.right = false;
        }
        restart();
        break;
      case 71:
        // G
        if (selected_link) {
          // set link direction to left only
          selected_link.left = true;
          selected_link.right = false;
        }
        restart();
        break;
      case 68:
        // D
        if (selected_node) {
          // toggle node reflexivity
          selected_node.pion = !selected_node.pion;
        } else if (selected_link) {
          // set link direction to right only
          selected_link.left = false;
          selected_link.right = true;
        }
        restart();
    }
  }
};

keyup = function() {
  lastKeyDown = -1;
  // ctrl
  if (d3.event.keyCode === 17) {
    circle.on('mousedown.drag', null).on('touchstart.drag', null);
    svg.classed('ctrl', false);
  }
};

// app starts here
svg.on('mousedown', mousedown).on('mousemove', mousemove).on('mouseup', mouseup);

d3.select(window).on('keydown', keydown).on('keyup', keyup);

restart();

$("#triche").on("click", function() {
  spoiler = !spoiler;
  return restart();
});

$("#jeu").on("click", function() {
  jeu = !jeu;
  premier_appel = jeu;
  $(".unique").toggle();
  if (jeu) {
    $("#jeu").text("Créer");
    joueur = "A";
  } else {
    $("#jeu").text("Jouer");
  }
  return restart();
});


//Drag an Drop interface
DnDFileController = function(selector, onDropCallback) {
  var el_;
  el_ = document.querySelector(selector);
  this.dragenter = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.add('dropping');
    return $("#upload").addClass("slim");
  };
  this.dragover = function(e) {
    e.stopPropagation();
    return e.preventDefault();
  };
  this.dragleave = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.remove('dropping');
    return $("#upload").removeClass("slim");
  };
  this.drop = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.remove('dropping');
    onDropCallback(e.dataTransfer.files, e);
    return $("#upload").removeClass("slim").hide();
  };
  el_.addEventListener('dragenter', this.dragenter, false);
  el_.addEventListener('dragover', this.dragover, false);
  el_.addEventListener('dragleave', this.dragleave, false);
  return el_.addEventListener('drop', this.drop, false);
};

//#################################################################
//Drag and Drop file
dnd = new DnDFileController('#upload', function(files) {
  var f, reader;
  f = files[0];
  reader = new FileReader;
  reader.onloadend = function(e) {
    var data, k, l, len, ref1, t;
    data = JSON.parse(this.result);
    console.log(data);
    pathsGroup.remove();
    circlesGroup.remove();
    
    // handles to link and node element groups
    pathsGroup = svg.append('svg:g');
    path = pathsGroup.selectAll('path');
    circlesGroup = svg.append('svg:g');
    circle = circlesGroup.selectAll('g');
    lastNodeId = data.lastNodeId;
    nodes = data.nodes;
    links = [];
    ref1 = data.links;
    for (k = 0, len = ref1.length; k < len; k++) {
      l = ref1[k];
      t = {};
      t.source = nodes[l.source.id];
      t.target = nodes[l.target.id];
      t.left = l.left;
      t.right = l.right;
      links.push(t);
    }
    console.log(links);
    force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(80).charge(-500).on('tick', tick);
    return restart();
  };
  reader.readAsText(f);
});

//###################################################################
$("#importJSON").on("click", function() {
  return $("#upload").show();
});

$("#upload .close").on("click", function() {
  return $("#upload").hide();
});

save = function(type) {
  var dataStr, dlAnchorElem, html, stringValue, svgBlob;
  dataStr = `data:text/${type};charset=utf-8,`;
  stringValue = prompt("Nom du fichier ?", stringValue);
  switch (type) {
    case "json":
      dataStr += encodeURIComponent(JSON.stringify({
        nodes: nodes,
        links: links,
        lastNodeId: lastNodeId
      }));
      break;
    case "svg":
      html = d3.select("#graf974").select("svg").attr("title", "svg_title").attr("version", 1.1).attr("xmlns", "http://www.w3.org/2000/svg").node().parentNode.innerHTML;
      svgBlob = new Blob([html], {
        type: "image/svg+xml;charset=utf-8"
      });
      dataStr = URL.createObjectURL(svgBlob);
  }
  dlAnchorElem = document.getElementById('save');
  dlAnchorElem.setAttribute("href", dataStr);
  dlAnchorElem.setAttribute("download", `${stringValue}.${type}`);
  return dlAnchorElem.click();
};

$(function() {
  //  console.log nodes,links
  $("#genJSON").on("click", function() {
    return save("json");
  });
  $("#genSVG").on("click", function() {
    return save("svg");
  });
  $("#hints, #rules, #defs, #matrice2").hide();
  $("#hintsToggler").on("click", function() {
    return $("#hints").toggle();
  });
  $("#rulesToggler").on("click", function() {
    return $("#rules").toggle();
  });
  $("#defsToggler").on("click", function() {
    return $("#defs").toggle();
  });
  return $("#matriceToggler").on("click", function() {
    return $("#matrice2").toggle();
  });
});
