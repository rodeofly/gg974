// Generated by CoffeeScript 2.3.0
var DnDFileController, autre, circle, circlesGroup, colors, coulJeu, couleur, couleurJ, dnd, drag_line, force, height, i, j, jeu, jouable, joueur, keydown, keyup, lastKeyDown, lastNodeId, links, m, modeJeu, mousedown, mousedown_link, mousedown_node, mousemove, mouseup, mouseup_node, nodes, path, pathsGroup, premier_appel, ref, resetMouseVars, restart, save, selected_link, selected_node, spliceLinksForNode, statut, svg, tick, voisins, width,
  indexOf = [].indexOf;

premier_appel = false;

// set up SVG for D3
width = 800;

height = 480;

colors = d3.scale.category10();

jeu = false;

modeJeu = "Col";

coulJeu = function(nodeId) {
  if (jeu) {
    if (statut[nodeId] === 2) {
      return "white";
    } else {
      return d3.rgb(colors(statut[nodeId]));
    }
  } else {
    return d3.rgb(colors(couleur[nodeId]));
  }
};

// define arrow markers for graph links
svg = d3.select('#graf').append('svg').attr('oncontextmenu', 'return false;').attr('width', width).attr('height', height);

// line displayed when dragging new nodes
drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');

// set up initial nodes and links
//  - nodes are known by 'id', not by index in array.
//  - reflexive edges are indicated on the node (as a bold black circle).
//  - links are always source < target; edge directions are set by 'left' and 'right'.
nodes = [
  {
    id: 0,
    reflexive: false
  },
  {
    id: 1,
    reflexive: false
  },
  {
    id: 2,
    reflexive: false
  },
  {
    id: 3,
    reflexive: false
  },
  {
    id: 4,
    reflexive: false
  },
  {
    id: 5,
    reflexive: false
  }
];

lastNodeId = 5;

couleur = [];

for (i = j = 0; j <= 10000; i = ++j) {
  couleur[i.toString()] = i;
}

links = [
  {
    source: nodes[0],
    target: nodes[1],
    left: false,
    right: false
  },
  {
    source: nodes[0],
    target: nodes[4],
    left: false,
    right: false
  },
  {
    source: nodes[0],
    target: nodes[5],
    left: false,
    right: false
  },
  {
    source: nodes[1],
    target: nodes[2],
    left: false,
    right: false
  },
  {
    source: nodes[2],
    target: nodes[3],
    left: false,
    right: false
  },
  {
    source: nodes[4],
    target: nodes[3],
    left: false,
    right: false
  },
  {
    source: nodes[4],
    target: nodes[5],
    left: false,
    right: false
  },
  {
    source: nodes[5],
    target: nodes[1],
    left: false,
    right: false
  },
  {
    source: nodes[5],
    target: nodes[2],
    left: false,
    right: false
  },
  {
    source: nodes[5],
    target: nodes[3],
    left: false,
    right: false
  }
];

statut = {};

for (i = m = 0, ref = lastNodeId; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {
  statut[i] = 2;
}

autre = {
  "Bleu": "Rouge",
  "Rouge": "Bleu"
};

couleurJ = {
  "Bleu": 0,
  "Rouge": 3
};

joueur = "Bleu";

voisins = function(sommet) {
  var arete, len, n, vois;
  vois = [];
  for (n = 0, len = links.length; n < len; n++) {
    arete = links[n];
    if (arete.source === sommet) {
      vois.push(statut[arete.target.id]);
    }
    if (arete.target === sommet) {
      vois.push(statut[arete.source.id]);
    }
  }
  return vois;
};

jouable = function(sommet) {
  var ref1, ref2;
  if (modeJeu === "Col") {
    ref1 = couleurJ[joueur], indexOf.call(voisins(sommet), ref1) < 0;
  }
  if (modeJeu === "Snort") {
    return ref2 = couleurJ[autre[joueur]], indexOf.call(voisins(sommet), ref2) < 0;
  }
};

// handles to link and node element groups
pathsGroup = svg.append('svg:g');

path = pathsGroup.selectAll('path');

circlesGroup = svg.append('svg:g');

circle = circlesGroup.selectAll('g');

// update force layout (called automatically each iteration)
tick = function() {
  // draw directed edges with proper padding from node centers
  path.attr('d', function(d) {
    var deltaX, deltaY, dist, normX, normY, sourcePadding, sourceX, sourceY, targetPadding, targetX, targetY;
    deltaX = d.target.x - d.source.x;
    deltaY = d.target.y - d.source.y;
    dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    normX = deltaX / dist;
    normY = deltaY / dist;
    sourcePadding = 12;
    targetPadding = 12;
    sourceX = d.source.x + sourcePadding * normX;
    sourceY = d.source.y + sourcePadding * normY;
    targetX = d.target.x - (targetPadding * normX);
    targetY = d.target.y - (targetPadding * normY);
    return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
  });
  return circle.attr('transform', function(d) {
    return `translate(${d.x}, ${d.y})`;
  });
};

// init D3 force layout
force = d3.layout.force().nodes(nodes).links(links).size([width / 2, height / 2]).linkDistance(80).charge(-500).on('tick', tick);

// mouse event vars
selected_node = null;

selected_link = null;

mousedown_link = null;

mousedown_node = null;

mouseup_node = null;

// only respond once per keydown
lastKeyDown = -1;

resetMouseVars = function() {
  mousedown_node = null;
  mouseup_node = null;
  mousedown_link = null;
};

// update graph (called when needed)
restart = function() {
  var arete, c1, c2, cell, enscoul, g, k, len, len1, len2, len3, n, na, o, p, q, r, ref1, ref2, ref3, s, sommet, sommet2, u, v, x, y;
  // path (link) group
  path = path.data(links);
  // update existing links
  path.style('stroke', "black").style('fill', "black").style('stroke-width', '4px').classed('selected', function(d) {
    return d === selected_link;
  });
  // add new links
  path.enter().append('svg:path').attr('class', 'link').style('stroke', "black").style('fill', "black").style('stroke-width', '4px').classed('selected', function(d) {
    return d === selected_link;
  }).on('mousedown', function(d) {
    if (d3.event.ctrlKey) {
      
      // select link
      mousedown_link = d;
      if (mousedown_link === selected_link) {
        selected_link = null;
      } else {
        selected_link = mousedown_link;
      }
      selected_node = null;
      return restart();
    }
  });
  
  // remove old links
  path.exit().remove();
  // circle (node) group
  // NB: the function arg is crucial here! nodes are known by id, not by index!
  circle = circle.data(nodes, function(d) {
    return d.id;
  });
  // update existing nodes (reflexive & selected visual states)
  circle.selectAll('circle').classed('selected', function(d) {
    return d === selected_node;
  }).style('fill', function(d) {
    return coulJeu(d.id);
  }).classed('reflexive', function(d) {
    return d.reflexive;
  });
  // add new nodes
  g = circle.enter().append('svg:g');
  g.append('svg:circle').attr('class', 'node').attr('r', 12).classed('selected', function(d) {
    return d === selected_node;
  //.style('fill', (d) -> if d == selected_node then d3.rgb(colors(couleur[d.id])).brighter().toString() else colors(couleur[d.id]))
  }).style('fill', function(d) {
    return coulJeu(d.id);
  }).style('stroke', function(d) {
    return d3.rgb(colors(couleur[d.id])).darker().toString();
  }).classed('reflexive', function(d) {
    return d.reflexive;
  }).on('mouseover', function(d) {
    if (!mousedown_node || d === mousedown_node) {
      return;
    }
    
    // enlarge target node
    d3.select(this).attr('transform', 'scale(1.1)');
  }).on('mouseout', function(d) {
    if (!mousedown_node || d === mousedown_node) {
      return;
    }
    
    // unenlarge target node
    d3.select(this).attr('transform', '');
  }).on('mousedown', function(d) {
    if (d3.event.ctrlKey) {
      return;
    }
    
    // select node
    mousedown_node = d;
    if (mousedown_node === selected_node) {
      selected_node = null;
    } else {
      selected_node = mousedown_node;
    }
    selected_link = null;
    // reposition drag line
    drag_line.classed('hidden', false).attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${mousedown_node.x}, ${mousedown_node.y}`);
    restart();
    if (jeu) {
      if (jouable(selected_node) || modeJeu === "Col") {
        statut[selected_node.id] = couleurJ[joueur];
        joueur = autre[joueur];
        $(".joueur").text(joueur);
        restart();
      }
    }
  }).on('mouseup', function(d) {
    var direction, link, source, target;
    if (!mousedown_node) {
      return;
    }
    
    // needed by FF
    drag_line.classed('hidden', true);
    // check for drag-to-self
    mouseup_node = d;
    if (mouseup_node === mousedown_node) {
      resetMouseVars();
      return;
    }
    // unenlarge target node
    d3.select(this).attr('transform', '');
    // add link to graph (update if exists)
    // NB: links are strictly source < target; arrows separately specified by booleans
    source = void 0;
    target = void 0;
    direction = void 0;
    if (mousedown_node.id < mouseup_node.id) {
      source = mousedown_node;
      target = mouseup_node;
      direction = 'right';
    } else {
      source = mouseup_node;
      target = mousedown_node;
      direction = 'left';
    }
    link = void 0;
    link = links.filter(function(l) {
      return l.source === source && l.target === target;
    })[0];
    if (!link) {
      link = {
        source: source,
        target: target,
        left: false,
        right: false
      };
      links.push(link);
    }
    // select new link
    selected_link = link;
    selected_node = null;
    return restart();
  });
  
  // show node IDs
  g.append('svg:text').attr('x', 0).attr('y', 4).attr('class', 'id').text(function(d) {
    return d.id;
  });
  // remove old nodes
  circle.exit().remove();
  // set the graph in motion
  force.start();
  // calculs sur les degrés et les couleurs
  $("#matrAdj").empty().append('<tr id="sommets2"></tr>');
  $("#sommets, #sommets2").empty().append("<th>sommets</th>");
  $("#entrants").empty().append("<th>degrés</th>");
  $("#conflits").empty();
  for (n = 0, len = nodes.length; n < len; n++) {
    sommet = nodes[n];
    $("#sommets").append(`<td>${sommet.id}</td>`);
    $("#sommets2").append(`<th>${sommet.id}</th>`);
    $("#matrAdj").append(`<tr id='sa${sommet.id}'><th>${sommet.id}</th></tr>`);
    for (o = 0, len1 = nodes.length; o < len1; o++) {
      sommet2 = nodes[o];
      $(`#sa${sommet.id}`).append("<td>0</td>");
    }
    na = 0;
    c1 = couleur[sommet.id];
    for (p = 0, len2 = links.length; p < len2; p++) {
      arete = links[p];
      if (arete.source === sommet) {
        na += 1;
        c2 = couleur[arete.target.id];
        if (c1 === c2 && !jeu) {
          $("#conflits").append(`<li>Les sommets ${sommet.id} et ${arete.target.id} sont de la même couleur</li>`);
        }
      }
      if (arete.target === sommet) {
        na += 1;
      }
    }
    $("#entrants").append(`<td>${na}</td>`);
  }
  enscoul = {};
  for (i = q = 0, ref1 = lastNodeId; (0 <= ref1 ? q <= ref1 : q >= ref1); i = 0 <= ref1 ? ++q : --q) {
    enscoul[couleur[i]] = couleur[i];
  }
  if (jeu) {
    $("#chroma1").text("");
  } else {
    $("#chroma1").text(`Le graphe est actuellement colorié en ${((function() {
      var results;
      results = [];
      for (k in enscoul) {
        v = enscoul[k];
        results.push(v);
      }
      return results;
    })()).length} couleurs. Peut-on faire moins ?`);
  }
  for (x = r = 0, ref2 = nodes.length; (0 <= ref2 ? r < ref2 : r > ref2); x = 0 <= ref2 ? ++r : --r) {
    for (y = s = 0, ref3 = nodes.length; (0 <= ref3 ? s < ref3 : s > ref3); y = 0 <= ref3 ? ++s : --s) {
      cell = $(`table#matrAdj tr:nth-child(${x + 2}) td:nth-child(${y + 2})`);
      for (u = 0, len3 = links.length; u < len3; u++) {
        arete = links[u];
        if (arete.source === nodes[x] && arete.target === nodes[y]) {
          cell.text(1);
        }
        if (arete.source === nodes[y] && arete.target === nodes[x]) {
          cell.text(1);
        }
      }
    }
  }
};

mousedown = function() {
  var node, point;
  // prevent I-bar on drag
  //d3.event.preventDefault();
  // because :active only works in WebKit?
  svg.classed('active', true);
  if (d3.event.ctrlKey || mousedown_node || mousedown_link || jeu) {
    return;
  }
  // insert new node at point
  point = d3.mouse(this);
  node = {
    id: ++lastNodeId,
    reflexive: false
  };
  couleur[node.id] = node.id;
  node.x = point[0];
  node.y = point[1];
  nodes.push(node);
  restart();
};

mousemove = function() {
  if (!mousedown_node || jeu) {
    return;
  }
  // update drag line
  drag_line.attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${(d3.mouse(this)[0])}, ${(d3.mouse(this)[1])}`);
  restart();
};

mouseup = function() {
  if (mousedown_node) {
    // hide drag line
    drag_line.classed('hidden', true).style('marker-end', '');
  }
  // because :active only works in WebKit?
  svg.classed('active', false);
  // clear mouse event vars
  resetMouseVars();
};

spliceLinksForNode = function(node) {
  var toSplice;
  toSplice = links.filter(function(l) {
    return l.source === node || l.target === node;
  });
  return toSplice.map(function(l) {
    return links.splice(links.indexOf(l), 1);
  });
};

keydown = function() {
  var index;
  d3.event.preventDefault();
  if (lastKeyDown !== -1) {
    return;
  }
  lastKeyDown = d3.event.keyCode;
  // ctrl
  if (d3.event.keyCode === 17) {
    circle.call(force.drag);
    svg.classed('ctrl', true);
  }
  if (!selected_node && !selected_link) {
    return;
  }
  switch (d3.event.keyCode) {
    // backspace
    case 8:
    case 46:
      // delete
      if (selected_node && !jeu) {
        nodes.splice(nodes.indexOf(selected_node), 1);
        spliceLinksForNode(selected_node);
      } else if (selected_link && !jeu) {
        links.splice(links.indexOf(selected_link), 1);
      }
      selected_link = null;
      selected_node = null;
      restart();
      break;
    // M pour moins (diminuer couleur)
    case 77:
    case 109:
      if (selected_node && !jeu) {
        index = selected_node.id;
        couleur[index] -= 1;
        if (couleur[index] < 0) {
          couleur[index] += 10;
        }
      }
      restart();
      break;
    // P pour plus (augmenter couleur)
    case 80:
    case 112:
      if (selected_node && !jeu) {
        index = selected_node.id;
        couleur[index] += 1;
        if (couleur[index] > 9) {
          couleur[index] -= 10;
        }
      }
      restart();
  }
};

keyup = function() {
  lastKeyDown = -1;
  // ctrl
  if (d3.event.keyCode === 17) {
    circle.on('mousedown.drag', null).on('touchstart.drag', null);
    svg.classed('ctrl', false);
  }
};

// app starts here
svg.on('mousedown', mousedown).on('mousemove', mousemove).on('mouseup', mouseup);

d3.select(window).on('keydown', keydown).on('keyup', keyup);

restart();

//Drag an Drop interface
DnDFileController = function(selector, onDropCallback) {
  var el_;
  el_ = document.querySelector(selector);
  this.dragenter = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.add('dropping');
    return $("#upload").addClass("slim");
  };
  this.dragover = function(e) {
    e.stopPropagation();
    return e.preventDefault();
  };
  this.dragleave = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.remove('dropping');
    return $("#upload").removeClass("slim");
  };
  this.drop = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.remove('dropping');
    onDropCallback(e.dataTransfer.files, e);
    return $("#upload").removeClass("slim").hide();
  };
  el_.addEventListener('dragenter', this.dragenter, false);
  el_.addEventListener('dragover', this.dragover, false);
  el_.addEventListener('dragleave', this.dragleave, false);
  return el_.addEventListener('drop', this.drop, false);
};

//#################################################################
//Drag and Drop file
// à  factoriser à l'occasion
dnd = new DnDFileController('#upload', function(files) {
  var f, reader;
  f = files[0];
  reader = new FileReader;
  reader.onloadend = function(e) {
    var data, l, len, n, ref1, t;
    data = JSON.parse(this.result);
    console.log(data);
    pathsGroup.remove();
    circlesGroup.remove();
    
    // handles to link and node element groups
    pathsGroup = svg.append('svg:g');
    path = pathsGroup.selectAll('path');
    circlesGroup = svg.append('svg:g');
    circle = circlesGroup.selectAll('g');
    lastNodeId = data.lastNodeId;
    nodes = data.nodes;
    links = [];
    ref1 = data.links;
    for (n = 0, len = ref1.length; n < len; n++) {
      l = ref1[n];
      t = {};
      t.source = nodes[l.source.id];
      t.target = nodes[l.target.id];
      t.left = false;
      t.right = false;
      links.push(t);
    }
    console.log(links);
    force = d3.layout.force().nodes(nodes).links(links).size([width / 2, height / 2]).linkDistance(80).charge(-200).on('tick', tick);
    return restart();
  };
  reader.readAsText(f);
});

//###################################################################
$("#importJSON").on("click", function() {
  return $("#upload").show();
});

$("#upload .close").on("click", function() {
  return $("#upload").hide();
});

save = function(type) {
  var dataStr, dlAnchorElem, html, stringValue, svgBlob;
  dataStr = `data:text/${type};charset=utf-8,`;
  stringValue = prompt("Nom du fichier ?", stringValue);
  switch (type) {
    case "json":
      dataStr += encodeURIComponent(JSON.stringify({
        nodes: nodes,
        links: links,
        lastNodeId: lastNodeId
      }));
      break;
    case "svg":
      html = d3.select("#graf").select("svg").attr("title", "svg_title").attr("version", 1.1).attr("xmlns", "http://www.w3.org/2000/svg").node().parentNode.innerHTML;
      svgBlob = new Blob([html], {
        type: "image/svg+xml;charset=utf-8"
      });
      dataStr = URL.createObjectURL(svgBlob);
  }
  dlAnchorElem = document.getElementById('save');
  dlAnchorElem.setAttribute("href", dataStr);
  dlAnchorElem.setAttribute("download", `${stringValue}.${type}`);
  return dlAnchorElem.click();
};

$(function() {
  //  console.log nodes,links
  $("#genJSON").on("click", function() {
    return save("json");
  });
  $("#genSVG").on("click", function() {
    return save("svg");
  });
  $("#hints, #rules, #defs, #matrice2").hide();
  $("#hintsToggler").on("click", function() {
    return $("#hints").toggle();
  });
  $("#rulesToggler").on("click", function() {
    return $("#rules").toggle();
  });
  $("#defsToggler").on("click", function() {
    return $("#defs").toggle();
  });
  $("#matriceToggler").on("click", function() {
    return $("#matrice2").toggle();
  });
  $("#bCol").on("click", function() {
    var n, ref1;
    jeu = !jeu;
    $(".unique").toggle();
    modeJeu = "Col";
    joueur = "Bleu";
    if (jeu) {
      statut = {};
      for (i = n = 0, ref1 = lastNodeId; (0 <= ref1 ? n <= ref1 : n >= ref1); i = 0 <= ref1 ? ++n : --n) {
        statut[i] = 2;
      }
    }
    return restart();
  });
  return $("#bSnort").on("click", function() {
    var n, ref1;
    jeu = !jeu;
    $(".unique").toggle();
    modeJeu = "Snort";
    joueur = "Bleu";
    if (jeu) {
      statut = {};
      for (i = n = 0, ref1 = lastNodeId; (0 <= ref1 ? n <= ref1 : n >= ref1); i = 0 <= ref1 ? ++n : --n) {
        statut[i] = 2;
      }
    }
    return restart();
  });
});
