// Generated by CoffeeScript 2.3.0
var DnDFileController, M, autre, circle, circlesGroup, colors, dnd, drag_line, force, height, jeu, joueur, keydown, keyup, lastKeyDown, lastNodeId, links, mousedown, mousedown_link, mousedown_node, mousemove, mouseup, mouseup_node, nodes, path, pathsGroup, premier_appel, resetMouseVars, restart, save, selected_link, selected_node, somme, spliceLinksForNode, svg, tick, width;

premier_appel = false;

// set up SVG for D3
width = 800;

height = 480;

colors = d3.scale.category10();

M = [];

somme = 0;

// define arrow markers for graph links
svg = d3.select('#graf974').append('svg').attr('oncontextmenu', 'return false;').attr('width', width).attr('height', height);

svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 4).attr('markerHeight', 4).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').attr('fill', '#000');

svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 4).attr('markerHeight', 4).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').attr('fill', '#000');


// line displayed when dragging new nodes
drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');

// set up initial nodes and links
//  - nodes are known by 'id', not by index in array.
//  - pion edges are indicated on the node (as a bold black circle).
//  - links are always source < target; edge directions are set by 'left' and 'right'.
nodes = [
  {
    id: 0,
    pion: false,
    depart: true,
    arrivee: false
  },
  {
    id: 1,
    pion: false,
    depart: false,
    arrivee: false
  },
  {
    id: 2,
    pion: false,
    depart: false,
    arrivee: false
  },
  {
    id: 3,
    pion: false,
    depart: false,
    arrivee: true
  },
  {
    id: 4,
    pion: true,
    depart: false,
    arrivee: true
  }
];

lastNodeId = 4;

links = [
  {
    source: nodes[0],
    target: nodes[1],
    poids: 4,
    left: false,
    right: true
  },
  {
    source: nodes[1],
    target: nodes[2],
    left: false,
    right: true,
    poids: 2
  },
  {
    source: nodes[1],
    target: nodes[3],
    left: false,
    right: true,
    poids: 4
  },
  {
    source: nodes[2],
    target: nodes[3],
    left: false,
    right: true,
    poids: 2
  },
  {
    source: nodes[2],
    target: nodes[4],
    left: false,
    right: true,
    poids: 5
  }
];

autre = {
  "A": "B",
  "B": "A"
};

joueur = "A";

// handles to link and node element groups
pathsGroup = svg.append('svg:g');

path = pathsGroup.selectAll('path');

circlesGroup = svg.append('svg:g');

circle = circlesGroup.selectAll('g');

// update force layout (called automatically each iteration)
tick = function() {
  // draw directed edges with proper padding from node centers
  path.attr('d', function(d) {
    var deltaX, deltaY, dist, normX, normY, sourcePadding, sourceX, sourceY, targetPadding, targetX, targetY;
    deltaX = d.target.x - d.source.x;
    deltaY = d.target.y - d.source.y;
    dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    normX = deltaX / dist;
    normY = deltaY / dist;
    sourcePadding = d.left ? 22 : 12;
    targetPadding = d.right ? 22 : 12;
    sourceX = d.source.x + sourcePadding * normX;
    sourceY = d.source.y + sourcePadding * normY;
    targetX = d.target.x - (targetPadding * normX);
    targetY = d.target.y - (targetPadding * normY);
    return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
  });
  return circle.attr('transform', function(d) {
    return `translate(${d.x}, ${d.y})`;
  });
};

// init D3 force layout
force = d3.layout.force().nodes(nodes).links(links).size([width * 0.8, height * 0.8]).linkDistance(80).charge(-500).on('tick', tick);

// mouse event vars
selected_node = null;

selected_link = null;

mousedown_link = null;

mousedown_node = null;

mouseup_node = null;

// only respond once per keydown
lastKeyDown = -1;

resetMouseVars = function() {
  mousedown_node = null;
  mouseup_node = null;
  mousedown_link = null;
};

jeu = false;

// mode jeu ou mode Ã©dition
// update graph (called when needed)
restart = function() {
  var arete, cell, coeff, e, g, i, j, len, len1, len2, len3, len4, m, n, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, sommeLigne, sommet, sommet2, u, v, w, x, y, z;
  
  // path (link) group
  path = path.data(links);
  // update existing links
  path.style('stroke', "black").style('fill', "black").style('stroke-width', function(d) {
    return d.poids + 'px';
  }).classed('selected', function(d) {
    return d === selected_link;
  }).style('marker-start', function(d) {
    if (d.left) {
      return 'url(#start-arrow)';
    } else {
      return '';
    }
  }).style('marker-end', function(d) {
    if (d.right) {
      return 'url(#end-arrow)';
    } else {
      return '';
    }
  });
  // add new links
  path.enter().append('svg:path').attr('class', 'link').style('stroke', "black").style('fill', "black").style('stroke-width', function(d) {
    return d.poids + 'px';
  }).classed('selected', function(d) {
    return d === selected_link;
  }).style('marker-start', function(d) {
    if (d.left) {
      return 'url(#start-arrow)';
    } else {
      return '';
    }
  }).style('marker-end', function(d) {
    if (d.right) {
      return 'url(#end-arrow)';
    } else {
      return '';
    }
  }).on('mousedown', function(d) {
    if (d3.event.ctrlKey || jeu) {
      
      // select link
      mousedown_link = d;
      if (mousedown_link === selected_link) {
        selected_link = null;
      } else {
        selected_link = mousedown_link;
      }
      selected_node = null;
    }
    return restart();
  });
  
  // remove old links
  path.exit().remove();
  $("#matrAdj").empty().append('<tr id="sommets2"></tr>');
  $("#sommets, #sommets2").empty().append("<th>sommets</th>");
  $("#departs").empty();
  $("#arrivees").empty();
  for (i = 0, len = nodes.length; i < len; i++) {
    sommet = nodes[i];
    if (!jeu) {
      sommet.pion = false;
    }
    sommet.arrivee = false;
    sommet.depart = false;
  }
  for (j = 0, len1 = nodes.length; j < len1; j++) {
    sommet = nodes[j];
    $("#sommets2").append(`<th>${sommet.id}</th>`);
    $("#matrAdj").append(`<tr id='sa${sommet.id}'><th>${sommet.id}</th></tr>`);
    for (m = 0, len2 = nodes.length; m < len2; m++) {
      sommet2 = nodes[m];
      $(`#sa${sommet.id}`).append("<td>0</td>");
    }
    [e, s] = [0, 0];
    for (n = 0, len3 = links.length; n < len3; n++) {
      arete = links[n];
      if (arete.source === sommet && arete.right) {
        s += 1;
      }
      if (arete.target === sommet && arete.left) {
        s += 1;
      }
      if (arete.target === sommet && arete.right) {
        e += 1;
      }
      if (arete.source === sommet && arete.left) {
        e += 1;
      }
      if (arete.source === sommet && !arete.right && !arete.left) {
        e += 1;
        s += 1;
      }
      if (arete.target === sommet && !arete.right && !arete.left) {
        e += 1;
        s += 1;
      }
    }
    if (s === 0 && e > 0) {
      $("#arrivees").append(`<li>${sommet.id}</li>`);
      sommet.arrivee = true;
    }
    if (e === 0 && s > 0) {
      sommet.depart = true;
      if (premier_appel) {
        sommet.pion = true;
        premier_appel = false;
      }
      $("#departs").append(`<li>${sommet.id}</li>`);
    }
  }
  M = [];
  for (x = o = 0, ref = nodes.length; (0 <= ref ? o < ref : o > ref); x = 0 <= ref ? ++o : --o) {
    M[x] = [];
    for (y = p = 0, ref1 = nodes.length; (0 <= ref1 ? p < ref1 : p > ref1); y = 0 <= ref1 ? ++p : --p) {
      M[x][y] = 0;
    }
  }
  for (x = q = 0, ref2 = nodes.length; (0 <= ref2 ? q < ref2 : q > ref2); x = 0 <= ref2 ? ++q : --q) {
    sommeLigne = 0;
    for (y = r = 0, ref3 = nodes.length; (0 <= ref3 ? r < ref3 : r > ref3); y = 0 <= ref3 ? ++r : --r) {
      if (x !== y) {
        coeff = 0;
        for (u = 0, len4 = links.length; u < len4; u++) {
          arete = links[u];
          if (arete.right && arete.source === nodes[x] && arete.target === nodes[y]) {
            coeff = arete.poids;
          }
          if (arete.left && arete.source === nodes[y] && arete.target === nodes[x]) {
            coeff = arete.poids;
          }
          if (!arete.left && !arete.right && arete.source === nodes[y] && arete.target === nodes[x]) {
            coeff = arete.poids;
          }
          if (!arete.left && !arete.right && arete.source === nodes[x] && arete.target === nodes[y]) {
            coeff = arete.poids;
          }
        }
        M[x][y] = 0.1 * coeff / (nodes.length - 1);
        sommeLigne += M[x][y];
      }
    }
    //    M[x][x] = 1.0-sommeLigne
    if (sommeLigne > 0) {
      for (y = v = 0, ref4 = nodes.length; (0 <= ref4 ? v < ref4 : v > ref4); y = 0 <= ref4 ? ++v : --v) {
        M[x][y] /= sommeLigne;
      }
    } else {
      M[x][x] = 1;
    }
  }
  for (x = w = 0, ref5 = nodes.length; (0 <= ref5 ? w < ref5 : w > ref5); x = 0 <= ref5 ? ++w : --w) {
    for (y = z = 0, ref6 = nodes.length; (0 <= ref6 ? z < ref6 : z > ref6); y = 0 <= ref6 ? ++z : --z) {
      cell = $(`table#matrAdj tr:nth-child(${x + 2}) td:nth-child(${y + 2})`);
      cell.text(M[x][y].toLocaleString().replace(".", ","));
    }
  }
  
  // circle (node) group
  // NB: the function arg is crucial here! nodes are known by id, not by index!
  circle = circle.data(nodes, function(d) {
    return d.id;
  });
  
  // update existing nodes (pion & selected visual states)
  circle.selectAll('circle').style('fill', function(d) {
    if (d === selected_node) {
      return d3.rgb(colors(d.id)).brighter().toString();
    } else {
      return d3.rgb(colors(d.id));
    }
  }).classed('pion', function(d) {
    return d.pion;
  }).classed('arrivee', function(d) {
    return d.arrivee;
  }).classed('depart', function(d) {
    return d.depart;
  });
  
  // add new nodes
  g = circle.enter().append('svg:g');
  g.append('svg:circle').attr('class', 'node').attr('r', 12).style('fill', function(d) {
    if (d === selected_node) {
      return d3.rgb(colors(d.id)).brighter().toString();
    } else {
      return d3.rgb(colors(d.id));
    }
  }).style('stroke', function(d) {
    return d3.rgb(colors(d.id)).darker().toString();
  }).classed('pion', function(d) {
    return d.pion;
  }).classed('arrivee', function(d) {
    return d.arrivee;
  }).classed('depart', function(d) {
    return d.depart;
  }).on('mouseover', function(d) {
    if (!mousedown_node || d === mousedown_node) {
      return;
    }
    
    // enlarge target node
    d3.select(this).attr('transform', 'scale(1.1)');
  }).on('mouseout', function(d) {
    if (!mousedown_node || d === mousedown_node) {
      return;
    }
    
    // unenlarge target node
    d3.select(this).attr('transform', '');
  }).on('mousedown', function(d) {
    if (d3.event.ctrlKey || jeu) {
      return;
    }
    
    // select node
    mousedown_node = d;
    if (mousedown_node === selected_node) {
      selected_node = null;
    } else {
      selected_node = mousedown_node;
    }
    selected_link = null;
    // reposition drag line
    drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${mousedown_node.x}, ${mousedown_node.y}`);
    restart();
  }).on('mouseup', function(d) {
    var direction, link, source, target;
    if (!mousedown_node) {
      return;
    }
    
    // needed by FF
    drag_line.classed('hidden', true).style('marker-end', '');
    // check for drag-to-self
    mouseup_node = d;
    if (mouseup_node === mousedown_node) {
      resetMouseVars();
      return;
    }
    // unenlarge target node
    d3.select(this).attr('transform', '');
    // add link to graph (update if exists)
    // NB: links are strictly source < target; arrows separately specified by booleans
    source = void 0;
    target = void 0;
    direction = void 0;
    if (mousedown_node.id < mouseup_node.id) {
      source = mousedown_node;
      target = mouseup_node;
      direction = 'right';
    } else {
      source = mouseup_node;
      target = mousedown_node;
      direction = 'left';
    }
    link = void 0;
    link = links.filter(function(l) {
      return l.source === source && l.target === target;
    })[0];
    if (link) {
      link[direction] = true;
    } else {
      link = {
        source: source,
        target: target,
        left: false,
        right: false,
        poids: 4
      };
      link[direction] = true;
      links.push(link);
    }
    // select new link
    selected_link = link;
    selected_node = null;
    return restart();
  });
  
  // show node IDs
  g.append('svg:text').attr('x', 0).attr('y', 4).attr('class', 'id').text(function(d) {
    return d.id;
  });
  
  // remove old nodes
  circle.exit().remove();
  // set the graph in motion
  force.start();
};

mousedown = function() {
  var node, point;
  // prevent I-bar on drag
  //d3.event.preventDefault();
  // because :active only works in WebKit?
  svg.classed('active', true);
  if (d3.event.ctrlKey || mousedown_node || mousedown_link || jeu) {
    return;
  }
  // insert new node at point
  point = d3.mouse(this);
  node = {
    id: ++lastNodeId,
    pion: false,
    depart: false,
    arrivee: false
  };
  node.x = point[0];
  node.y = point[1];
  nodes.push(node);
  restart();
};

mousemove = function() {
  if (!mousedown_node) {
    return;
  }
  // update drag line
  drag_line.attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${(d3.mouse(this)[0])}, ${(d3.mouse(this)[1])}`);
  restart();
};

mouseup = function() {
  if (mousedown_node) {
    // hide drag line
    drag_line.classed('hidden', true).style('marker-end', '');
  }
  // because :active only works in WebKit?
  svg.classed('active', false);
  // clear mouse event vars
  resetMouseVars();
};

spliceLinksForNode = function(node) {
  var toSplice;
  toSplice = links.filter(function(l) {
    return l.source === node || l.target === node;
  });
  return toSplice.map(function(l) {
    return links.splice(links.indexOf(l), 1);
  });
};

keydown = function() {
  d3.event.preventDefault();
  if (lastKeyDown !== -1) {
    return;
  }
  lastKeyDown = d3.event.keyCode;
  // ctrl
  if (d3.event.keyCode === 17) {
    circle.call(force.drag);
    svg.classed('ctrl', true);
  }
  if (!selected_node && !selected_link) {
    return;
  }
  if (!jeu) {
    switch (d3.event.keyCode) {
      // backspace
      case 8:
      case 46:
        // delete
        if (selected_node) {
          nodes.splice(nodes.indexOf(selected_node), 1);
          spliceLinksForNode(selected_node);
        } else if (selected_link) {
          links.splice(links.indexOf(selected_link), 1);
        }
        selected_link = null;
        selected_node = null;
        restart();
        break;
      case 65:
        // A
        if (selected_link) {
          // set link direction to both left and right
          selected_link.left = false;
          selected_link.right = false;
        }
        restart();
        break;
      case 71:
        // G
        if (selected_link) {
          // set link direction to left only
          selected_link.left = true;
          selected_link.right = false;
        }
        restart();
        break;
      case 68:
        // D
        if (selected_node) {
          // toggle node reflexivity
          selected_node.pion = !selected_node.pion;
        } else if (selected_link) {
          // set link direction to right only
          selected_link.left = false;
          selected_link.right = true;
        }
        restart();
        break;
      case 77:
        // M
        if (selected_link) {
          selected_link.poids = Math.max(selected_link.poids - 1, 1);
        }
        restart();
        break;
      case 80:
        // P
        if (selected_link) {
          selected_link.poids = Math.min(selected_link.poids + 1, 10);
        }
        restart();
    }
  }
};

keyup = function() {
  lastKeyDown = -1;
  // ctrl
  if (d3.event.keyCode === 17) {
    circle.on('mousedown.drag', null).on('touchstart.drag', null);
    svg.classed('ctrl', false);
  }
};

// app starts here
svg.on('mousedown', mousedown).on('mousemove', mousemove).on('mouseup', mouseup);

d3.select(window).on('keydown', keydown).on('keyup', keyup);

restart();

$("#jeu").on("click", function() {
  jeu = !jeu;
  premier_appel = jeu;
  
  //  numeropion = 0
  $("#lancer").toggle();
  $("#idjoueur").toggle();
  if (jeu) {
    $("#jeu").text("CrÃ©er");
    joueur = "A";
  } else {
    $("#jeu").text("Jouer");
  }
  return restart();
});

$("#lancer").on("click", function() {
  var k, loi, seuil, sommet;
  sommet = nodes.filter(function(d) {
    return d.pion;
  })[0].index;
  if (nodes[sommet].arrivee) {
    return $("#aff").text(`Fini : ${autre[joueur]} a gagnÃ© le jeu.`);
  } else {
    loi = M[sommet];
    seuil = Math.random();
    somme = 0;
    k = 0;
    while (!(somme > seuil)) {
      somme += loi[k];
      k += 1;
    }
    k -= 1;
    nodes[sommet].pion = false;
    nodes[k].pion = true;
    $("#aff").text(`La probabilitÃ© que le pion passe par lÃ  Ã©tait de ${loi[k].toLocaleString().replace('.', ',')}`);
    joueur = autre[joueur];
    $(".joueurId").text(joueur);
    return restart();
  }
});

//Drag an Drop interface
DnDFileController = function(selector, onDropCallback) {
  var el_;
  el_ = document.querySelector(selector);
  this.dragenter = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.add('dropping');
    return $("#upload").addClass("slim");
  };
  this.dragover = function(e) {
    e.stopPropagation();
    return e.preventDefault();
  };
  this.dragleave = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.remove('dropping');
    return $("#upload").removeClass("slim");
  };
  this.drop = function(e) {
    e.stopPropagation();
    e.preventDefault();
    el_.classList.remove('dropping');
    onDropCallback(e.dataTransfer.files, e);
    return $("#upload").removeClass("slim").hide();
  };
  el_.addEventListener('dragenter', this.dragenter, false);
  el_.addEventListener('dragover', this.dragover, false);
  el_.addEventListener('dragleave', this.dragleave, false);
  return el_.addEventListener('drop', this.drop, false);
};

//#################################################################
//Drag and Drop file
dnd = new DnDFileController('#upload', function(files) {
  var f, reader;
  f = files[0];
  reader = new FileReader;
  reader.onloadend = function(e) {
    var data, i, l, len, ref, ref1, t;
    data = JSON.parse(this.result);
    console.log(data);
    pathsGroup.remove();
    circlesGroup.remove();
    
    // handles to link and node element groups
    pathsGroup = svg.append('svg:g');
    path = pathsGroup.selectAll('path');
    circlesGroup = svg.append('svg:g');
    circle = circlesGroup.selectAll('g');
    lastNodeId = data.lastNodeId;
    nodes = data.nodes;
    links = [];
    ref = data.links;
    for (i = 0, len = ref.length; i < len; i++) {
      l = ref[i];
      t = {};
      t.source = nodes[l.source.id];
      t.target = nodes[l.target.id];
      t.left = l.left;
      t.right = l.right;
      t.poids = (ref1 = l.poids) != null ? ref1 : 4;
      links.push(t);
    }
    console.log(links);
    force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(80).charge(-500).on('tick', tick);
    return restart();
  };
  reader.readAsText(f);
});

//###################################################################
$("#importJSON").on("click", function() {
  return $("#upload").show();
});

$("#upload .close").on("click", function() {
  return $("#upload").hide();
});

save = function(type) {
  var dataStr, dlAnchorElem, html, stringValue, svgBlob;
  dataStr = `data:text/${type};charset=utf-8,`;
  stringValue = prompt("Nom du fichier ?", stringValue);
  switch (type) {
    case "json":
      dataStr += encodeURIComponent(JSON.stringify({
        nodes: nodes,
        links: links,
        lastNodeId: lastNodeId
      }));
      break;
    case "svg":
      html = d3.select("#graf974").select("svg").attr("title", "svg_title").attr("version", 1.1).attr("xmlns", "http://www.w3.org/2000/svg").node().parentNode.innerHTML;
      svgBlob = new Blob([html], {
        type: "image/svg+xml;charset=utf-8"
      });
      dataStr = URL.createObjectURL(svgBlob);
  }
  dlAnchorElem = document.getElementById('save');
  dlAnchorElem.setAttribute("href", dataStr);
  dlAnchorElem.setAttribute("download", `${stringValue}.${type}`);
  return dlAnchorElem.click();
};

$(function() {
  //  console.log nodes,links
  $("#genJSON").on("click", function() {
    return save("json");
  });
  $("#genSVG").on("click", function() {
    return save("svg");
  });
  $("#hints, #matrice2, #lancer, #idjoueur").hide();
  $("#hintsToggler").on("click", function() {
    return $("#hints").toggle();
  });
  return $("#matriceToggler").on("click", function() {
    return $("#matrice2").toggle();
  });
});
